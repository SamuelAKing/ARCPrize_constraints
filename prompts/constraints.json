{
    "constraints":
    {
        "16b78196":"1.All shapes are considered to consist of only one colour (not black) and to be of connectivity 4.\n2.The divider is the shape that contains a full column or a full row. If it contains a full row, it is horizontal, and if it contains a full column, it is vertical.\n3.The output is of the same dimensions as the input.\n4.The input and output dividers are equal.\n5.Each shape in the input is translationally equal to a shape in the output.\n6.There is the same number of shapes in the input and in the output.\n7.In the output, if the divider is vertical, in each row, there are no black pixels between two non-black pixels.\n8.In the output, if the divider is horizontal, in each column, there are no black pixels between two non-black pixels.",
        "6e453dd6" : "1. The output is of the same dimensions as the input. \n2. All grey pixels in the input are grey in the output \n3.Each black shape of connectivity 4 in the output is translationally equal to a black shape in the input, occupying exactly the same rows, and it has at least one pixel directly to the left of a grey pixel.\n4. The input and output have the same number of black shapes of connectivity 4.\n5. In the output, each pixel is red if and only if it is to the left of a grey pixel and it is in the same row as a pixel that has a grey pixel two spaces to the right and that is in a pink shape of connectivity 4 that is orthogonally adjacent to a black shape of connectivity 4 and whose pixels are all orthogonally adjacent to four pixels that are either black or pink.\n6. In the output, each pixel is pink, unless it is grey in the input, it is red, or it is black.",
        "71e489b6" : "1. An irregularity is a pixel that is part of a one-colored shape of connectivity 8 containing less than 4 pixels or a pixel that doesn’t have at least 2 orthogonal neighbors that are the same color as itself, or 1 if it is adjacent to the border.\n2. The output is of the same dimensions as the input.\n3. A pixel is orange in the output if and only if it is orthogonally or diagonally adjacent to a black irregularity in the input and it is not a black irregularity in the input.\n4. Unless it is orange in the output, each pixel that is a blue irregularity in the input is black in the output.\n5. Unless it is orange or it is a blue irregularity in the input, each pixel in the output is of the same color as in the input.",
        "78332cb0":"1. Each shape of connectivity 4 and of non-pink colors in the input is translationally equal to a shape of connectivity 4 and of non-pink colors in the output.\n2. The number of shapes of connectivity 4 and of non-pink colors is the same in the input and the output.\n3. In the output, each pink pixel in the output is orthogonally adjacent to exactly two non-pink pixels: either they are both of the color of the background or neither of them is.\n4. In the output, in each pink shape of connectivity 4, there is exactly one pixel that is orthogonally adjacent to exactly two non-pink pixels that both aren’t of the color of the background.",
        "7b5033c1":"1. The dimensions of the output are (1, number of non-background pixels in the input).\n2. A pixel in the input and a pixel in the output that are both in the shape of non-background colours and of connectivity 4 and that have the same distance this shape from the highest non-background pixel that only has one non-background neighbor are of the same color." 
    },
    "code":
    {
        "16b78196":"#Definition: All shapes are considered to consist of only one colour (not black) and to be of connectivity 4.\ninput_shapes = []\noutput_shapes = []\nfor color in COLORS:\n    if color != COLOR_mapping[\"black\"]:\n        [input_shapes.append(shape) for shape in find_shapes(input,4,[color])]\n        [output_shapes.append(shape) for shape in find_shapes(output,4,[color])]\n\n#Definition: The divider is the shape that contains a full column or a full row. If it contains a full row, it is horizontal, and if it contains a full column, it is vertical.\ndef divider(shapes):\n    #the divider is a list containing a shape and a string in [\"horizontal\",\"vertical\"] that states whether the divider is horizontal or vertical\n    for shape in shapes:\n        if True in [-1 not in row for row in shape.grid]:\n            return [shape,\"horizontal\"]\n        if True in [-1 not in row for row in shape.rotate(1).grid]:\n            return [shape,\"vertical\"]\n    return [shapes[0],None]\ninput_divider = divider(input_shapes)\noutput_divider = divider(output_shapes)\n\nconstraints = []\n\n#Constraint: The output is of the same dimensions as the input.\nconstraints.append(len(input)==len(output) and len(input[0])==len(output[0]))\n\n#Constraint: The input and output dividers are exactly equal.\nconstraints.append(input_divider[0].equals(output_divider[0]))\n    \n#Constraint: Each shape in the input is translationally equal to a shape in the output.\nconstraints.append(False not in [True in [input_shape.translationally_equals(output_shape) for output_shape in output_shapes] for input_shape in input_shapes])\n\n#Constraint: There is the same number of shapes in the input and in the output.\nconstraints.append(len(input_shapes)==len(output_shapes))\n\n#Used for the following two constraints\ndef num_partitions(lst, splitter):\n    count = 0\n    segment = False\n    for item in lst:\n        if item == splitter:\n            if segment:\n                count += 1\n            segment = False\n        else:\n            segment = True\n    if segment:\n        count += 1\n    return count\n\n#Constraint: In the output, if the divider is vertical, in all rows, there are no black pixels between two non-black pixels.\nif output_divider[1] == \"vertical\":\n    constraints.append(False not in [num_partitions(row,0)<=1 for row in output])\nelse:\n    constraints.append(True)\n\n#Constraint: In the output, if the divider is horizontal, in all columns, there are no black pixels between two non-black pixels.\nif output_divider[1] == \"horizontal\":\n    constraints.append(False not in [num_partitions(column,0)<=1 for column in [[output[k][i] for k in range(len(output))]for i in range(len(output[0]))]])\nelse:\n    constraints.append(True)",
        "6e453dd6":"constraints = []\n\n#Constraint: The output is of the same dimensions as the input.\nconstraints.append(len(input)==len(output) and len(input[0])==len(output[0]))\n\n#Constraint: All grey pixels in the input are grey in the output\nconstraints.append(True not in [True in [input[i][k] == COLOR_mapping[\"gray\"] and output[i][k] != COLOR_mapping[\"gray\"] for k in range(len(input[0]))] for i in range(len(input))])\n\n#Constraint: Each black shape of connectivity 4 in the output is translationally equal to a black shape in the input, occupying exactly the same rows, and it has at least one pixel directly to the left of a grey pixel.\ninput_black_shapes = find_shapes(input,4,[COLOR_mapping[\"black\"]])\noutput_black_shapes = find_shapes(output,4,[COLOR_mapping[\"black\"]])\n\ntests = []\nfor output_black_shape in output_black_shapes:\n    is_correct = False\n    for input_black_shape in input_black_shapes:\n        if output_black_shape.translationally_equals(input_black_shape) and [True in [pixel!=-1 for pixel in row] for row in output_black_shape.grid] == [True in [pixel!=-1 for pixel in row] for row in input_black_shape.grid]:\n            for i in range(len(input)):\n                for k in range(len(input[0])):\n                    if output_black_shape.grid[i][k]==COLOR_mapping[\"black\"] and output[i][k+1]==COLOR_mapping[\"gray\"]:\n                        is_correct = True\n    tests.append(is_correct)\nconstraints.append(False not in tests)\n\n#Constraint: The input and output have the same number of black shapes of connectivity 4.\nconstraints.append(len(input_black_shapes)==len(output_black_shapes))\n\n#Constraint: In the output, each pixel is red if and only if it is to the left of a grey pixel and it is in the same row as a pixel that has a grey pixel two spaces to the right and that is in a pink shape of connectivity 4 that is orthogonally adjacent to a black shape of connectivity 4 and whose pixels are all orthogonally adjacent to four pixels that are either black or pink.\noutput_pink_shapes = find_shapes(output,4,[COLOR_mapping[\"pink\"]])\npink_shapes_fitting_criteria = []\npadded_output = [[output[i][k] if (i in range(len(output)) and k in range(len(output[0]))) else -1 for k in range(-1,len(output[0])+1)]for i in range(-1,len(output)+1)]\nfor output_black_shape in output_black_shapes:\n    adjacent_pink_shapes = []\n    for pink_shape in output_pink_shapes:\n        for i in range(1,len(input)-1):\n            for k in range(1,len(input[0])-1):\n                if pink_shape not in adjacent_pink_shapes:\n                    if pink_shape.grid[i][k] != -1:\n                        if True in [output_black_shape.grid[i+neighbor[0]][k+neighbor[1]] != -1 for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]]:\n                           adjacent_pink_shapes.append(pink_shape)\n    for adjacent_pink_shape in adjacent_pink_shapes:\n        keep_shape = True\n        for i in range(len(input)):\n            for k in range(len(input[0])):\n                if keep_shape:\n                    if adjacent_pink_shape.grid[i][k] != -1:\n                        if False in [padded_output[i+neighbor[0]+1][k+neighbor[1]+1] in [COLOR_mapping[\"black\"],COLOR_mapping[\"pink\"]] for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]]:\n                            keep_shape = False\n        if keep_shape:\n            pink_shapes_fitting_criteria.append(adjacent_pink_shape)\nrows_with_red = []\nfor pink_shape_fitting_criteria in pink_shapes_fitting_criteria:\n    for row_idx in range(len(pink_shape_fitting_criteria.grid)):\n        if row_idx not in rows_with_red:\n            for pixel_idx in range(len(pink_shape_fitting_criteria.grid[row_idx])-2):\n                if pink_shape_fitting_criteria.grid[row_idx][pixel_idx] != -1:\n                    if output[row_idx][pixel_idx+2] == COLOR_mapping[\"gray\"]:\n                        rows_with_red.append(row_idx)\n                        if row_idx == 0:\n                            i = row_idx\n                            k = pixel_idx\ntests = []\nfor i in range(len(input)):\n    for k in range(len(input[0])):\n        tests.append((COLOR_mapping[\"gray\"] in output[i][0:k] and i in rows_with_red) is (output[i][k] == COLOR_mapping[\"red\"]))\nconstraints.append(False not in tests)\n\n#Constraint: In the output, each pixel is pink, unless it is grey in the input, it is red, or it is black.\nis_correct = True\nfor i in range(len(input)):\n    for k in range(len(input[0])):\n        if input[i][k] != COLOR_mapping[\"gray\"] and output[i][k] != COLOR_mapping[\"red\"] and output[i][k] != COLOR_mapping[\"black\"] and output[i][k] != COLOR_mapping[\"pink\"]:\n            is_correct = False\nconstraints.append(is_correct)",
        "71e489b6":"#Definition: An irregularity is a pixel that is part of a one-colored shape of connectivity 8 containing less than 4 pixels or a pixel that doesn’t have at least 2 orthogonal neighbors that are the same color as itself, or 1 if it is adjacent to the border.\nblue_black_input_shapes = find_shapes(input,8,[COLOR_mapping[\"blue\"]])+find_shapes(input,8,[COLOR_mapping[\"black\"]])\nirregularities = []\nfor input_shape in blue_black_input_shapes:\n    pixels = 0\n    for row in input_shape.grid:\n        for pixel in row:\n            if pixel != -1:\n                pixels += 1\n    if pixels < 4:\n        for i in range(len(input_shape.grid)):\n            for k in range(len(input_shape.grid[0])):\n                if input_shape.grid[i][k] != -1:\n                    irregularities.append([i,k])\npadded_input = [[input[i][k] if (i in range(len(input)) and k in range(len(input[0]))) else -1 for k in range(-1,len(input[0])+1)] for i in range(-1,len(input)+1)]\nfor i in range(len(input)):\n    for k in range(len(input[0])):\n        if [i,k] not in irregularities:\n            same_neighbors = 0\n            for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]:\n                if padded_input[i+neighbor[0]+1][k+neighbor[1]+1] == input[i][k]:\n                    same_neighbors += 1\n            if same_neighbors < 2-(i in [0,len(input)-1] or k in [0,len(input[0])-1]):\n                irregularities.append([i,k])\n\nconstraints = []\n\n#Constraint: The output is of the same dimensions as the input.\nconstraints.append(len(input)==len(output) and len(input[0])==len(output[0]))\n\n#Constraint: A pixel is orange in the output if and only if is is orthogonally or diagonally adjacent to a black irregularity in the input and it is not a black irregularity in the input.\nis_correct = True\nfor i in range(len(input_shape.grid)):\n    for k in range(len(input_shape.grid[0])):\n        if (output[i][k] == COLOR_mapping[\"orange\"]) != (True in [[i+neighbor[0],k+neighbor[1]] in irregularities and input[i+neighbor[0]][k+neighbor[1]] == COLOR_mapping[\"black\"] for neighbor in [[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]]] and not([i,k] in irregularities and input[i][k] == COLOR_mapping[\"black\"])):\n            is_correct = False\nconstraints.append(is_correct)\n\n#Constraint: Unless it is orange in the output, each pixel that is a blue irregularity in the input is black in the output.\nis_correct = True\nfor i in range(len(input_shape.grid)):\n    for k in range(len(input_shape.grid[0])):\n        if output[i][k] != COLOR_mapping[\"orange\"]:\n            if (input[i][k]==COLOR_mapping[\"blue\"] and [i,k] in irregularities) and not (output[i][k]==COLOR_mapping[\"black\"]):\n                is_correct = False\nconstraints.append(is_correct)\n\n#Constraint: Unless it is orange or it is a blue irregularity in the input, each pixel in the output is of the same color as in the input.\nis_correct = True\nfor i in range(len(input_shape.grid)):\n    for k in range(len(input_shape.grid[0])):\n        if not(output[i][k] == COLOR_mapping[\"orange\"] or (input[i][k]==COLOR_mapping[\"blue\"] and [i,k] in irregularities)):\n            if input[i][k] != output[i][k]:\n                is_correct = False\nconstraints.append(is_correct)",
        "78332cb0":"constraints = []\n\n#Constraint: Each shape of connectivity 4 and of non-pink colors in the input is translationally equal to a shape of connectivity 4 and of non-pink colors in the output.\ninput_shapes = find_shapes(input,4,[color for color in COLORS if color != COLOR_mapping[\"pink\"]])\noutput_shapes = find_shapes(output,4,[color for color in COLORS if color != COLOR_mapping[\"pink\"]])\nconstraints.append(False not in [True in [input_shape.translationally_equals(output_shape) for output_shape in output_shapes] for input_shape in input_shapes])\n\n#Constraint: The number of shapes of connectivity 4 and of non-pink colors is the same in the input and the output.\nconstraints.append(len(input_shapes)==len(output_shapes))\n\n#Constraint: In the output, each pink pixel in the output is orthogonally adjacent to exactly two non-pink pixels: either they are both of the color of the background or neither of them is.\n_,background_color = find_background(output)\npadded_output = [[output[i][k] if (i in range(len(output)) and k in range(len(output[0]))) else -1 for k in range(-1,len(output[0])+1)]for i in range(-1,len(output)+1)]\nis_correct = True\nfor i in range(len(output)):\n    for k in range(len(output[0])):\n        if output[i][k] == COLOR_mapping[\"pink\"]:\n            neighbors = [padded_output[i+neighbor[0]+1][k+neighbor[1]+1] for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]]\n            if not(neighbors.count(COLOR_mapping[\"pink\"]) + neighbors.count(-1) == 2 and (neighbors.count(background_color) == 2 or neighbors.count(background_color) == 0)):\n                is_correct = False\nconstraints.append(is_correct)\n\n#Constraint: In the output, in each pink shape of connectivity 4, there is exactly one pixel that is orthogonally adjacent to exactly two non-pink pixels that both aren’t of the color of the background.\npink_shapes = find_shapes(output,4,[COLOR_mapping[\"pink\"]])\nis_correct = True\nfor pink_shape in pink_shapes:\n    neighbors = []\n    for i in range(len(output)):\n        for k in range(len(output[0])):\n            if pink_shape.grid[i][k] == COLOR_mapping[\"pink\"]:\n                neighbors.append([padded_output[i+neighbor[0]+1][k+neighbor[1]+1] for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]].count(background_color))\n    if neighbors.count(0) != 1:\n        is_correct = False\nconstraints.append(is_correct)",
        "7b5033c1":"constraints = []\n\n#Constraint: The dimensions of the output are (1, number of non-background pixels in the input).\nbackground,background_color = find_background(input)\nnum_pixels = 0\nfor row in background:\n    for pixel in row:\n        if pixel == -1:\n            num_pixels += 1\nconstraints.append(len(output)==num_pixels and len(output[0])==1)\n\n#Constraint: A pixel in the input and a pixel in the output that are both in the shape of non-background colours and of connectivity 4 and that have the same distance this shape from the highest non-background pixel that only has one non-background neighbor are of the same color.\nis_correct = True\ninput_shape = find_shapes(input,4,[color for color in COLORS if color != background_color])[0]\noutput_shape = find_shapes(output,4,[color for color in COLORS if color != background_color])[0]\npadded_input_shape = [[input_shape.grid[i][k] if (i in range(len(input_shape.grid)) and k in range(len(input_shape.grid[0]))) else -1 for k in range(-1,len(input_shape.grid[0])+1)]for i in range(-1,len(input_shape.grid)+1)]\npadded_output_shape = [[output_shape.grid[i][k] if (i in range(len(output_shape.grid)) and k in range(len(output_shape.grid[0]))) else -1 for k in range(-1,len(output_shape.grid[0])+1)]for i in range(-1,len(output_shape.grid)+1)]\ninput_pixels_one_neighbor = []\noutput_pixels_one_neighbor = []\nfor i in range(len(input)):\n    for k in range(len(input[0])):\n        if input_shape.grid[i][k] != -1:\n            if [padded_input_shape[i+neighbor[0]+1][k+neighbor[1]+1] != -1 for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]].count(True) == 1:\n                input_pixels_one_neighbor.append([i,k])\nfor i in range(len(output)):\n    for k in range(len(output[0])):\n        if output_shape.grid[i][k] != -1:\n            if [padded_output_shape[i+neighbor[0]+1][k+neighbor[1]+1] != -1 for neighbor in [[0,1],[1,0],[0,-1],[-1,0]]].count(True) == 1:\n                output_pixels_one_neighbor.append([i,k])\nif len(output_pixels_one_neighbor)>0:\n    highest_input_pixel = [point for point in input_pixels_one_neighbor if min([point_[0] for point_ in input_pixels_one_neighbor])==point[0]][0]\n    highest_output_pixel = [point for point in output_pixels_one_neighbor if min([point_[0] for point_ in output_pixels_one_neighbor])==point[0]][0]\n    input_pixel_distance = []\n    output_pixel_distance = []\n    for i in range(len(input)):\n        for k in range(len(input[0])):\n            if input_shape.grid[i][k] != -1:\n                input_pixel_distance.append([input_shape.grid[i][k],input_shape.distance([i,k],highest_input_pixel)])\n    for i in range(len(output)):\n        for k in range(len(output[0])):\n            if output_shape.grid[i][k] != -1:\n                output_pixel_distance.append([output_shape.grid[i][k],output_shape.distance([i,k],highest_output_pixel)])\n    constraints.append(set(frozenset(sublist) for sublist in input_pixel_distance)==set(frozenset(sublist) for sublist in output_pixel_distance))\n    for sublist in input_pixel_distance:\n        if sublist not in output_pixel_distance:\n            is_correct = False\n    constraints.append(is_correct and len(input_pixel_distance)==len(output_pixel_distance))\nelse:\n    constraints.append(False)"
    }
}