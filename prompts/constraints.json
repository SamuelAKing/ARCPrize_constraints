{
    "constraints":
    {
        "332f06d7":"1.All shapes are considered to be one-colored and of connectivity 4\n2.The output is of the same dimensions as the input\n3.In both input and output, the black shape must retain its dimensions and be adjacent on at least three sides to either green pixels or the grid border\n4.The number of black and green pixels is the same in the output and the input\n5.Black pixels in the input are blue in the outpu\n6.Blue pixels in the input are blue in the output, unless they are blac\n7.In the output, the black shape is positioned at the minimum distance within the blue shape from its position in the input among the positions that respect all of the above constraints.",
        "16b78196":"1.All shapes are considered to consist of only one colour (not black) and to be of connectivity 4.\n2.The divider is the shape that contains a full column or a full row. If it contains a full row, it is horizontal, and if it contains a full column, it is vertical.\n3.The output is of the same dimensions as the input.\n4.The input and output dividers are equal.\n5.Each shape in the input is translationally equal to a shape in the output.\n6.There is the same number of shapes in the input and in the output.\n7.In the output, if the divider is vertical, in each row, there are no black pixels between two non-black pixels.\n8.In the output, if the divider is horizontal, in each column, there are no black pixels between two non-black pixels."
    },
    "code":
    {
        "16b78196":"#Definition: All shapes are considered to consist of only one colour (not black) and to be of connectivity 4.\ninput_shapes = []\noutput_shapes = []\nfor color in COLORS:\n    if color != COLOR_mapping[\"black\"]:\n        [input_shapes.append(shape) for shape in find_shapes(input,4,[color])]\n        [output_shapes.append(shape) for shape in find_shapes(output,4,[color])]\n\n#Definition: The divider is the shape that contains a full column or a full row. If it contains a full row, it is horizontal, and if it contains a full column, it is vertical.\ndef divider(shapes):\n    #the divider is a list containing a shape and a string in [\"horizontal\",\"vertical\"] that states whether the divider is horizontal or vertical\n    for shape in shapes:\n        if True in [-1 not in row for row in shape.grid]:\n            return [shape,\"horizontal\"]\n        if True in [-1 not in row for row in shape.rotate(1).grid]:\n            return [shape,\"vertical\"]\n    return [shapes[0],None]\ninput_divider = divider(input_shapes)\noutput_divider = divider(output_shapes)\n\nconstraints = []\n\n#Constraint: The output is of the same dimensions as the input.\nconstraints.append(len(input)==len(output) and len(input[0])==len(output[0]))\n\n#Constraint: The input and output dividers are exactly equal.\nconstraints.append(input_divider[0].equals(output_divider[0]))\n    \n#Constraint: Each shape in the input is translationally equal to a shape in the output.\nconstraints.append(False not in [True in [input_shape.translationally_equals(output_shape) for output_shape in output_shapes] for input_shape in input_shapes])\n\n#Constraint: There is the same number of shapes in the input and in the output.\nconstraints.append(len(input_shapes)==len(output_shapes))\n\n#Used for the following two constraints\ndef num_partitions(lst, splitter):\n    count = 0\n    segment = False\n    for item in lst:\n        if item == splitter:\n            if segment:\n                count += 1\n            segment = False\n        else:\n            segment = True\n    if segment:\n        count += 1\n    return count\n\n#Constraint: In the output, if the divider is vertical, in all rows, there are no black pixels between two non-black pixels.\nif output_divider[1] == \"vertical\":\n    constraints.append(False not in [num_partitions(row,0)<=1 for row in output])\nelse:\n    constraints.append(True)\n\n#Constraint: In the output, if the divider is horizontal, in all columns, there are no black pixels between two non-black pixels.\nif output_divider[1] == \"horizontal\":\n    constraints.append(False not in [num_partitions(column,0)<=1 for column in [[output[k][i] for k in range(len(output))]for i in range(len(output[0]))]])\nelse:\n    constraints.append(True)"
    }
}